class {

	variables.cwd = expandPath(".") & "/";
	variables.config = {
		outputDir: "_site",
		ignore: [],
		passthru: []
	};
	variables.ignoreDirs = [ cwd & "_includes/", cwd & "." ];
	variables.collections = { "all" : [], "tags" : [], "byTag" : {}, "global" : {} };
	variables.process = {};
	variables.baseData    = { "layouts" : {}, "views" : {} };

	variables.documents = []; // list of renderable documents found
	variables.templates = []; // data required to render each document

	/**
	 * Main build function
	 */
	function build(){
		processPassthruFiles();
		variables.documents.each(doc => {
			if ( process.verbose ?: false ) printLn("Processing document: " & doc.path & doc.name);
			processTemplate(doc.path & doc.name);
		});
		// processTemplate must have fun to exec the following
		processCollectionsData();
		processPagination();
		generateStatic();
	}

	/**
	 * Main entry point
	 */
	function main(args = []){
		if(!args.len()) {
			printLn("No arguments provided");
			cliExit(1)
		}

		getProcessConfig();
		// Load config before scanning so ignores/outputDir are respected
		if(variables.process.hasConfig) getSSGConfig();
		listDocuments();
		if(variables.process.hasIncludes) getIncludes();
		if(variables.process.hasData) getGlobalData();
		if(variables.process.applicationHelper) getApplicationHelper();
		// getSSGConfig() moved earlier

		var command = args[1];

		switch(command) {
			case "build":
				build();
				break;
			case "list":
				printLn(variables.documents.map(doc => doc.path & doc.name).toList(char(10)));
				break;
			case "help":
				printLn("Available commands: build, list, help");
				printLn("Use 'boxlang ssg.bx build' to generate the static site.");
				printLn("Use 'boxlang ssg.bx list' to list all documents.");
				printLn("Use 'boxlang ssg.bx help' to display this help message.");
				break;
			default:
				printLn("Unknown command: " & command);
				cliExit(1);
		}

		cliExit(0);
	}

	// ***********************************************************************************
	// Supporting functions
	// ***********************************************************************************

	/**
	 * Write generated content to files
	 */
	function generateStatic(){
		templates.each( ( prc ) => {
			if ( prc.published ) {
				try{
					// Render content; optionally trim whitespace if enabled
					var rendered = renderTemplate( prc );
					var contents = rendered;
					if ( (config.minify ?: false) ) {
						contents = rendered.listToArray(char(10)).filter(line => len(trim(line)) > 0).toList(char(10)) & char(10);
					}

					directoryCreate(
						getDirectoryFromPath( prc.outFile ),
						true,
						true
					);

					if ( process.verbose ?: false ) {
						print.greyline(
							" [ " & prc.inFile & " ] -> " &
							"/" & replace( prc.outFile, cwd, "", "all" ) &
							"  [" & prc.fileExt & "]"
						);
					} else {
						printLn( "Writing file: /" & replace( prc.outFile, cwd, "", "all" ) );
					}
					fileWrite( prc.outFile, contents );
				}
				catch ( any e ) {
					printLn( prc);
					printLn(e)
					abort;
				}
			}
		} );
	}

	/**
	 * Get applicationHelper.cfm if it exists
	 */
	function getApplicationHelper(){
		try {
			include "#cwd#_includes/applicationHelper.bxm" ;
		} catch ( any e ) {
			error( "Error loading applicationHelper.bxm :: " & e.message );
		}
	}

	/**
	 * Load `_data/**.json` files to `collections.global` if any exist
	 */
	function getGlobalData(){
		// Load all .json files from _data directory recursively
		var dataDir = cwd & "_data";
		if ( !directoryExists( dataDir ) ) return;
		var jsonFiles = directoryList(dataDir, true, "path", (any path) => path.findNoCase(".json"));

		jsonFiles.each((dataFile) => {
			// Get file name without extension
			var fileStem = getFileFromPath(dataFile).listFirst(".");
			// Get relative path parts as array
			var relPath = getDirectoryFromPath(dataFile).replace(dataDir, "");
			var pathParts = relPath.len() ? relPath.listToArray("/") : [];

			// Walk or create nested structure in collections.global
			var target = collections.global;
			for (var part in pathParts) {
				if (!target.keyExists(part)) target[part] = {};
				target = target[part];
			}

			// Deserialize JSON and assign to correct location
			target[fileStem] = jsonDeserialize(fileRead(dataFile, "utf-8"));
		});
	}

	/**
	 * Load layouts and views and any associated front matter
	 */
	function getIncludes(){
		// build arrays of valid layouts/views
		var layoutsDir = cwd & "_includes/layouts";
		var includesDir = cwd & "_includes";

		var layouts = directoryExists(layoutsDir) ? directoryList(layoutsDir, false, "path", "*.bxm") : [];
		layouts.each((layout) => {
			var stem = listFirst(getFileFromPath(layout), ".");
			process.layouts.append(stem);
			var data = getTemplateData(layout);
			if (data.keyExists("content")) data.delete("content");
			baseData["layouts"][stem] = data;
		});
		var views = directoryExists(includesDir) ? directoryList(includesDir, false, "path", (path) => {
			return path.findNoCase(".bxm") && !path.findNoCase("layouts") && !path.findNoCase("applicationHelper.bxm");
		}) : [];
		views.each((view) => {
			var stem = listFirst(getFileFromPath(view), ".");
			process.views.append(stem);
			var data = getTemplateData(view);
			if (data.keyExists("content")) data.delete("content");
			baseData["views"][stem] = data;
		});

	}

	/**
	 * Calculate the output filename
	 *
	 * @prc request context for the page
	 */
	function getOutfile( required struct prc ){
		// Cache site directory prefix
		var siteDir = cwd & config.outputDir;
		var outFile = "";

		if (prc.type == "post") {
			// For posts, use slug (or fileSlug) and file extension
			var relPathArr = prc.inFile.replace(cwd, "").listToArray("/");
			if (relPathArr.len()) {
				relPathArr[relPathArr.len()] = (prc.keyExists("slug") ? prc.slug : prc.fileSlug) & "." & prc.fileExt;
				outFile = siteDir & "/" & relPathArr.toList("/");
			}
		} else if (len(prc.permalink)) {
			// If permalink is set and ends with '/', write to index.html under that path
			if ( right(prc.permalink,1) == "/" ) {
				outFile = siteDir & prc.permalink & "index.html";
				prc.fileExt = "html";
			} else {
				outFile = siteDir & prc.permalink;
				var stem = listLast(prc.permalink, "/");
				if (stem.find(".")) {
					prc.fileExt = stem.listRest(".");
				} else {
					prc.fileExt = "";
				}
			}
		} else {
			// Default: use input file's directory and name
			var fileName = getFileFromPath(prc.inFile).listFirst(".");
			var outDir = getDirectoryFromPath(prc.inFile).replace(cwd, "/");
			outFile = siteDir & outDir & fileName & "." & prc.fileExt;
		}
		prc.outFile = outFile;
	}

	/**
	 * Calculate permalink
	 *
	 * @prc request context for the page
	 */
	function getPermalink( required struct prc ){
		// Remove _site/ prefix and split path into array
		var sitePrefix = cwd & config.outputDir & "/";
		var relPath = prc.outFile.replace(sitePrefix, "");
		var pathParts = relPath.listToArray("/");

		// Handle last part: remove .html extension and "index" filename
		var lastIdx = pathParts.len();
		var addTrailingSlash = false;
		if (lastIdx > 0) {
			var lastPart = pathParts[lastIdx];
			if (prc.fileExt == "html") lastPart = lastPart.listFirst(".");
			if (lastPart == "index") { lastPart = ""; addTrailingSlash = true; }
			pathParts[lastIdx] = lastPart;
		}

		// Remove empty trailing part if present
		if (pathParts.len() > 0 && pathParts[pathParts.len()] == "" && !addTrailingSlash) pathParts.deleteAt(pathParts.len());

		// Join parts to form permalink
		prc.permalink = "/" & pathParts.toList("/");
		if ( addTrailingSlash && right(prc.permalink,1) != "/" ) prc.permalink &= "/";
	}

	/**
	 * Detect options
	 */
	function getProcessConfig(){
		variables.process[ "applicationHelper" ] = fileExists( cwd & "_includes/applicationHelper.bxm" );
		variables.process[ "hasIncludes" ]       = directoryExists( cwd & "_includes" ) ? true : false;
		variables.process[ "hasData" ]           = directoryExists( cwd & "_data" ) ? true : false;
		variables.process[ "hasConfig" ]         = fileExists( cwd & "ssg-config.json" ) ? true : false;
		variables.process[ "layouts" ]           = [];
		variables.process[ "views" ]             = [];
	}

	/**
	 * Load the current build configuration from file if it exists, otherweise return defaults
	 */
	function getSSGConfig(){
        try {
            variables.config = JSONDeserialize( fileRead( variables.cwd & "ssg-config.json", "utf-8" ) );
            for ( var dir in config.ignore ) {
                if ( directoryExists( variables.cwd & dir ) ) ignoreDirs.append( variables.cwd & dir );
            }
            // always ignore the configured output directory
            var outDirIgnore = variables.cwd & config.outputDir & "/";
            if ( !ignoreDirs.find( outDirIgnore ) ) ignoreDirs.append( outDirIgnore );
		} catch ( any e ) {
			printLn( "Error loading SSG config: " & e.message );
		}
	}

	/**
	 * Get front matter and content of a document
	 */
	function getTemplateData( required string fname ){
		// Initialize variables
		var payload = {};
		var yaml = "";
		var body = "";
		var isBXM = fname.findNoCase(".bxm") ? true : false;
		var lines = [];

		// Read all lines from file
		var openFile = fileOpen(fname, "read");
		try {
			while (!fileIsEOF(openFile)) {
				arrayAppend(lines, rTrim(fileReadLine(openFile)));
			}
		} catch (any e) {
			rethrow;
		} finally {
			fileClose(openFile);
		}

		// Detect front matter at start of file
		var fmStart = !isBXM ? lines.find("---") : lines.find("<!---");
		if (fmStart == 1) {
			var fmEnd = !isBXM ? lines.findAll("---")[2] : lines.findAll("--->")[1];
			// Extract YAML front matter and body
			for (var i = 2; i < fmEnd; i++) yaml &= lines[i]  & char(10);
			for (var i = fmEnd + 1; i <= lines.len(); i++) body &= lines[i] & char(10);
			if (yaml.len()) payload.append(yamlDeserialize(trim(yaml)));
		} else {
			// No front matter, treat all as body
			body = arrayToList(lines, char(10));
		}

		// Flatten tags if nested array
		if (payload.keyExists("tags") && isArray(payload.tags) && isArray(payload.tags[1])) {
			payload.tags = payload.tags[1];
		}

		// Set content property, convert markdown if not BXM
		payload["content"] = isBXM ? body : markdown(body);

		return payload;
	}

	/**
	 * List all renderable documents in the project
	 */
	function listDocuments(){
		var fileList = directoryList(variables.cwd, true, "path", (any path) => {
			var p = arguments.path;
			if ( !( p.findNoCase(".md") || p.findNoCase(".bxm") ) || p.findNoCase("readme.md") ) return false;
			// Exclude any path that lives under an ignored directory prefix
			return !ignoreDirs.find( (dir) => left( p, len(dir) ) == dir );
		});
		variables.documents = fileList.map((file) => {
			return {
				name: getFileFromPath(file),
				path: getDirectoryFromPath(file)
			};
		});
	}

	/**
	 * a function to quickly paginate data
	 *
	 * @data     the data to be paginated
	 * @pageSize items per page
	 */
	function paginate( required array data, required numeric pageSize ){
		var output       = [];
		var currentChunk = 1;

		if ( pageSize > 1 ) output[ 1 ] = [];
		data.each( ( item, index ) => {
			if ( pageSize > 1 ) {
				output[ currentChunk ].append( item );
			} else {
				output.append( item, true );
			}
			if ( index % pageSize == 0 && index < data.len() && pageSize > 1 ) output[ ++currentChunk ] = [];
		} );
		return output;
	}

	/**
	 * Generates data for `collections` scope
	 */
	function processCollectionsData(){
		// Add templates to collections
		templates.each((template) => {
			var type = lCase( template.type ?: "" );
			var isPaginated = template.keyExists("pagination");
			if (!template.excludeFromCollections && !isPaginated) {
				collections.all.append(template);
				if (type.len()) {
					if (!collections.keyExists(type)) collections[type] = [];
					collections[type].append(template);
				}
			}
		});

		// Special processing for posts
		if (collections.keyExists("post")) {
			// Sort posts by date descending
			collections.post.sort((e1, e2) => dateCompare(e2.date, e1.date));

			// Build tag list and byTag mapping
			collections.post.each((post) => {
				if (post.keyExists("tags")) {
					for (var tag in post.tags) {
						if (!collections.tags.findNoCase(tag)) {
							collections.tags.append(tag);
						}
						var slugifiedTag = slugify(tag);
						if (!collections.byTag.keyExists(slugifiedTag)) collections.byTag[slugifiedTag] = [];
						collections.byTag[slugifiedTag].append(post);
					}
				}
			});
			collections.tags = collections.tags.sort("text");
		}
	}

	/**
	 * Generate templates based on paginated data
	 */
	function processPagination(){
		var additions = [];
		var originalLen = templates.len();
		for ( var __i = 1; __i <= originalLen; __i++ ) {
			var prc = templates[ __i ];
			if ( prc.keyExists( "pagination" ) ) {
				var data      = prc.pagination.data;
				var size      = prc.pagination.keyExists( "size" ) ? prc.pagination.size : 1;
				var targetKey = prc.pagination.keyExists( "alias" ) ? prc.pagination.alias : "pagedData";
				// data is a string, try to retrieve from variables
				if ( isSimpleValue( data ) ) {
					data = structGet( prc.pagination.data );
					// if data is a structure, return the struct key list as an array
					if ( isStruct( data ) ) {
						// if data is a struct, return the struct keys for iteration
						data = structKeyList( data ).listSort( "textnocase", "asc" ).listToArray();
					}
				}

				// set the parent prc scope for the paginated templates
				var parent_prc = duplicate( prc );
				// If parent has no explicit permalink, base it on fileSlug
				if ( !( parent_prc._explicitPermalink ?: false ) ) {
					parent_prc.permalink = "/" & parent_prc.fileSlug & "/";
					getOutfile( parent_prc );
				}

				// ensure parent template is not rendered (mutate original entry)
				prc.published = false;

				var paged = paginate( data = data, pageSize = size );

				// Precompute per-page permalinks for navigation
				var pagePermalinks = [];
				for ( var i = 1; i <= paged.len(); i++ ) {
					var candidate = parent_prc.permalink;
					var pageVal   = paged[ i ];
					// Replace alias placeholder only when the page value is simple (size == 1 case)
					if ( size == 1 && isSimpleValue( pageVal ) ) {
						candidate = candidate.replace( "{{" & targetKey & "}}", pageVal );
					}

					// If no placeholders present and this is a multi-item pagination,
					// generate conventional "/page/<n>/" URLs for pages after the first
					var hasPagePlaceholders = candidate.findNoCase( "{{page}}" ) || candidate.findNoCase( "{{pageNumber}}" );
					if ( size > 1 && !hasPagePlaceholders && i > 1 ) {
						if ( right(candidate,1) != "/" ) candidate &= "/";
						candidate &= "page/" & i & "/";
					}

					// Support page number placeholders
					if ( candidate.findNoCase( "{{page}}" ) ) candidate = candidate.replace( "{{page}}", i );
					if ( candidate.findNoCase( "{{pageNumber}}" ) ) candidate = candidate.replace( "{{pageNumber}}", i );
					pagePermalinks[ i ] = candidate;
				}
					// Ensure the first page uses the parent's permalink only for multi-item pages
					if ( paged.len() >= 1 && size > 1 && !parent_prc.permalink.findNoCase("{{") ) pagePermalinks[ 1 ] = parent_prc.permalink;

				paged.each( ( page, index ) => {
					var page_prc          = duplicate( parent_prc );
					page_prc[ targetKey ] = page;
					// Build this page's permalink
					var builtPermalink    = pagePermalinks[ index ];
					// If this is the first page, use canonical first URL
					if ( index == 1 ) {
						var canonicalFirst = builtPermalink;
						if ( size > 1 ) {
							var hasPlaceholder = parent_prc.permalink.findNoCase("{{page}}") || parent_prc.permalink.findNoCase("{{pageNumber}}");
							if ( hasPlaceholder ) {
								canonicalFirst = parent_prc.permalink;
								canonicalFirst = canonicalFirst.replace("{{page}}", "");
								canonicalFirst = canonicalFirst.replace("{{pageNumber}}", "");
								// clean up any double slashes and ensure trailing slash
								while ( canonicalFirst.find("//") ) canonicalFirst = canonicalFirst.replace("//", "/");
								if ( right(canonicalFirst,1) != "/" ) canonicalFirst &= "/";
							} else if ( !parent_prc.permalink.findNoCase("{{") ) {
								canonicalFirst = parent_prc.permalink;
							}
						}
						page_prc.permalink = canonicalFirst;
						getOutfile( page_prc );
					} else {
						// For subsequent pages, use the built pagination permalink
						page_prc.permalink = builtPermalink;
						getOutfile( page_prc );
					}
					// If the original data reference was a struct and the page is a single key, merge that data
					if (
						isSimpleValue( prc.pagination.data ) &&
						isStruct( structGet( prc.pagination.data ) ) &&
						isSimpleValue( page )
					) {
						page_prc.append( structGet( prc.pagination.data )[ page ] );
					}
						getPermalink( page_prc );
					// Inject pagination navigation info
					var totalPages  = paged.len();
					var totalItems  = isArray( data ) ? data.len() : 0;
					// Canonical first href: if multi-item and parent has placeholders, strip them to get base; else use parent's permalink
					var hasPlaceholder = parent_prc.permalink.findNoCase("{{page}}") || parent_prc.permalink.findNoCase("{{pageNumber}}");
					var canonicalFirst = parent_prc.permalink;
					if ( size > 1 ) {
						if ( hasPlaceholder ) {
							canonicalFirst = canonicalFirst.replace("{{page}}", "");
							canonicalFirst = canonicalFirst.replace("{{pageNumber}}", "");
							while ( canonicalFirst.find("//") ) canonicalFirst = canonicalFirst.replace("//", "/");
							if ( right(canonicalFirst,1) != "/" ) canonicalFirst &= "/";
						}
					}
					var prevHref = "";
					if ( index > 1 ) {
						prevHref = pagePermalinks[ index - 1 ];
						// When navigating to page 1 in multi-item pagination, always use canonicalFirst
						if ( index - 1 == 1 && size > 1 ) prevHref = canonicalFirst;
					}
					var nav = {
						"pageNumber"  : index,
						"pageSize"    : size,
						"totalPages"  : totalPages,
						"totalItems"  : totalItems,
						"href"        : {
							"current" : page_prc.permalink,
							"previous": prevHref,
							"next"    : ( index < totalPages ) ? pagePermalinks[ index + 1 ] : "",
							"first"   : canonicalFirst,
							"last"    : pagePermalinks[ totalPages ]
						}
					};
					// Add a simple list of pages [{number, href, current}]
					nav[ "pages" ] = [];
					for ( var p = 1; p <= totalPages; p++ ) {
						var pageHref = ( p == 1 ) ? canonicalFirst : pagePermalinks[ p ];
						nav.pages.append({ "number": p, "href": pageHref, "current": p == index });
					}
						page_prc[ "paginationInfo" ] = nav;

						additions.append( page_prc );
					// tag and template type processing
					if ( page_prc.keyExists( "tags" ) && page_prc.tags.len() ) {
						for ( var tag in page_prc.tags ) {
							if ( !collections.tags.findNoCase( tag ) ) collections.tags.append( tag );
							var slugifiedTag = slugify( tag );
							if ( !collections.byTag.keyExists( slugifiedTag ) ) collections.byTag[ slugifiedTag ] = [];
							collections.byTag[ slugifiedTag ].append( page_prc );
						}
					}
					// add page to types
					if ( !collections.keyExists( page_prc.type ) && page_prc.type.len() )
						collections[ page_prc.type ] = [];
					if ( page_prc.type.len() ) collections[ lCase( page_prc.type ) ].append( page_prc );
					// add to all collection unless excluded
					if ( !page_prc.excludeFromCollections ) collections.all.append( page_prc );
				} );
			}
		}
		// Append after to avoid mutating during iteration
		additions.each( (p) => templates.append( p ) );
	}

	/**
	 * Purge output directory and move static files
	 */
	function processPassthruFiles(){
		// delete the _site directory if it exists
		if ( directoryExists( cwd & config.outputDir ) ) {
			directoryDelete( cwd & config.outputDir, true );
		}
		// recreate the directory
		directoryCreate( cwd & config.outputDir );

		try {
			// passthru directories
			for ( var dir in config.passthru ) {
					if ( fileExists( cwd & dir ) ) {
						fileCopy( cwd & dir, cwd & config.outputDir & "/" & dir );
					} else {
						directoryCopy( cwd & dir, cwd & config.outputDir & "/" & dir, true );
					}
			}
		} catch ( any e ) {
			error( e.message );
		}
	}

	/**
	 * Builds the PRC scope for a given template
	 *
	 * @template full path to the template to read
	 */
	function processTemplate( template ){
		// Initialize template metadata
		var prc = {
			"build_start"            : "",
			"fileSlug"               : getFileFromPath(template).listFirst("."),
			"inFile"                 : template,
			"outFile"                : "",
			"title"                  : "",
			"description"            : "",
			"published"              : true,
			"date"                   : "",
			"lastModified"           : dateTimeFormat(getFileInfo(template).lastModified, "iso"),
			"content"                : "",
			"type"                   : "page",
			"layout"                 : "main",
			"view"                   : "",
			"permalink"              : "",
			"fileExt"                : "html",
			"excludeFromCollections" : false
		};
		var userFileExt = "";
		// Merge front matter from template
		var templateData = getTemplateData(template);
		if(templateData.keyExists("fileExt") && templateData.fileExt != "") userFileExt = templateData.fileExt;
		prc.append(templateData);
		// Track if permalink was explicitly provided in front matter
		prc._explicitPermalink = ( templateData.keyExists("permalink") && len(templateData.permalink) );

		// Merge layout metadata if available, without overwriting
		var layoutMeta = baseData.layouts.keyExists(prc.layout) ? baseData.layouts[prc.layout] : false;
		if (layoutMeta) prc.append(duplicate(layoutMeta), false);

		// Merge view metadata, prioritizing explicit view over type
		var hasView = len(prc.view);
		if (!hasView && baseData.views.keyExists(prc.type)) {
			prc.append(duplicate(baseData.views[prc.type]), false);
		} else if (hasView && baseData.views.keyExists(prc.view)) {
			prc.append(duplicate(baseData.views[prc.view]), false);
		}

		// Only process if published is true
		if (isBoolean(prc.published) && prc.published) {
			// Build output file path initially
			getOutfile(prc);
			// Handle permalinks while preserving trailing slash
			if (len(prc.permalink)) {
				// Ensure leading slash only; do not strip trailing slash
				if ( left(prc.permalink,1) != "/" ) prc.permalink = "/" & prc.permalink;
				var lastSeg = listLast(prc.permalink, "/");
				if ( lastSeg.find(".") ) prc.fileExt = lastSeg.listRest(".");
				if ( len(userFileExt) ) prc.fileExt = userFileExt;
				// Recompute outFile to align with final permalink + fileExt
				getOutfile(prc);
			} else {
				getPermalink(prc);
			}
			// Set view to type if not already set
			if (!prc.view.len() && prc.type.len()) {
				prc.view = prc.type;
			}
			// Add processed template to collections
			templates.append(prc);
		}
	}

	/**
	 * returns rendered html for a template and view
	 *
	 * @prc request context for the current page
	 */
	function renderTemplate( prc ){
		var renderedHtml = "";
		var template     = "";

		try {
			// template is CF markup
			if ( prc.inFile.findNoCase( ".bxm" ) ) {
				if ( process.hasIncludes && process.views.find( prc.view ) && prc.layout != "none" ) {
					// render the cfml in the template first
					template =  prc.inFile;

					bx:savecontent variable="prc.content" {
						include template;
					}

					// overlay the view
					template = cwd & "_includes/" & prc.view & ".bxm";

					bx:savecontent variable="renderedHtml" {
						include template;
					}
				} else {
					// view was not found, just render the template
					template =  prc.inFile ;

					bx:savecontent variable="renderedHtml" {
						include template;
					}
				}
			}

			// template is markdown
			if ( prc.inFile.findNoCase( ".md" ) ) {

				if ( process.hasIncludes && process.views.find( prc.view ) && prc.layout != "none" ) {
					template =  cwd & "_includes/" & prc.view & ".bxm";
					bx:savecontent variable="renderedHtml" {
						include template;
					}
				} else {
					renderedHtml = prc.content;
				}
			}

			// skip layout if "none" is specified
			if (
				prc.layout != "none" &&
				process.hasIncludes &&
				process.layouts.find( prc.layout )
			) {
				template =  cwd & "_includes/layouts/" & prc.layout & ".bxm";

				bx:savecontent variable="renderedHtml" {
					include template;
				}
			}

		} catch ( any e ) {
			dump(prc);
			printLn( "Error rendering template: " & e.message );
		}

		// if ( isXML( trim( toString(renderedHtml) ) ) ) prc.fileExt = "xml";

		// Optionally tidy HTML (can be expensive); otherwise return as-is
		if ( prc.fileExt == "html" ) {
			return ( config.tidyHtml ?: false ) ? htmlParse( renderedHtml ).html() : trim( renderedHtml );
		}
		return trim( renderedHtml );
	}

}
